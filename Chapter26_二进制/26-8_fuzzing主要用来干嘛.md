### fuzzing 主要是用来干嘛

**1. 探索代码路径（Code Coverage）**

Fuzzing 的一个核心目标是最大化代码覆盖率。传统的测试可能只会测试程序的“阳光大道”，而 fuzzing 则会试图探索那些不寻常的、可能存在漏洞的角落

例如，一个**覆盖率引导的 fuzzer**（如 AFL 或 LibFuzzer）会记录下每个输入所执行的代码路径。如果一个新的输入能够触发一条未曾被执行过的代码路径，fuzzer 就会将这个输入保留下来，并对其进行变异，以期能更深入地探索该路径。这种方法使得 fuzzer 能够自动绕过复杂的逻辑检查，深入到程序的核心功能中去

**2. 内存安全漏洞检测**

许多安全漏洞都与内存操作有关，比如：

- **缓冲区溢出**：向一个固定大小的缓冲区写入了超过其容量的数据，导致相邻的内存区域被覆盖
- **空指针解引用**：程序试图访问一个空指针指向的内存
- **整数溢出**：在进行算术运算时，结果超出了变量类型的最大值，导致意外的结果

Fuzzing 工具通过监控程序的**内存访问行为**来检测这些漏洞。例如，fuzzer 可以使用 Sanitizer 工具（如 AddressSanitizer、MemorySanitizer）来在运行时追踪内存读写，一旦发现非法访问，就会立即报告

**3. 绕过输入验证**

攻击者通常需要绕过程序的输入验证逻辑才能触发漏洞。从二进制角度来看，fuzzing 能够通过**变异输入的字节**来绕过这些验证

例如，一个网络协议解析器可能期望数据包的某个字段是一个特定的值。Fuzzer 会随机改变这个字段的字节，并观察解析器的行为。如果变异后的数据包导致程序进入一个异常状态，fuzzer 就找到了一个潜在的漏洞