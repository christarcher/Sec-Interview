### 代码执行、命令执行的函数有哪些

**PHP**

在 PHP 中，有很多函数可以执行系统命令或代码。它们是 PHP 漏洞利用中最常见的攻击入口

**命令执行函数**

- `exec()`: 执行一个外部程序，不返回输出结果，通常需要使用参数获取

  ```php
  exec('whoami', $output);
  print_r($output);
  ```

- `passthru()`: 直接将命令的输出传递到浏览器

  ```php
  passthru('ls -la');
  ```

- `shell_exec()`: 通过 shell 执行命令，并将整个输出结果作为字符串返回

  ```php
  $output = shell_exec('id');
  echo $output;
  ```

- `system()`: 执行外部程序并显示输出

  ```php
  system('netstat -an');
  ```

- `popen()` 和 `proc_open()`: 都可以打开一个进程文件指针，允许对进程进行双向 I/O 操作

  ```
  $handle = popen('ls', 'r');
  ```

- `pcntl_exec()`: 在 PHP CLI 环境中，用新的程序替换当前进程

**代码执行函数**

- `eval()`: 将字符串作为 PHP 代码来执行。这是最常见的代码执行漏洞函数

  ```php
  $code = $_GET['code'];
  eval($code);
  ```

- `assert()`: 在 PHP 7.2 之前，`assert()` 函数可以执行字符串参数

  ```php
  assert($_POST['pass']);
  ```

- `create_function()`: 用于创建一个匿名函数

  ```php
  $func = create_function('', 'return ' . $_GET['pass'] . ';');
  $func();
  ```

- `call_user_func()` 和 `call_user_func_array()`: 调用一个用户函数，如果参数是用户可控的，可以用来执行任意函数

- `array_map()`: 将回调函数作用到给定数组的每个元素上

- `unserialize()`: 反序列化函数，如果序列化数据中包含一个恶意对象，可以导致对象注入，从而触发魔术方法（如 `__destruct()`），最终实现代码执行

**Python**

Python 的 Web 应用中也经常出现类似的问题

**命令执行函数**

- `os.system()`: 执行 shell 命令

- `os.popen()`: 执行 shell 命令，并返回一个文件对象

- `subprocess` 模块: 这是更安全、更现代的模块，但如果参数处理不当，同样会造成命令注入

  ```python
  import subprocess
  cmd = 'ls ' + user_input
  subprocess.call(cmd, shell=True) # 当 shell=True 时，可能存在命令注入
  ```

**代码执行函数**

- `eval()`: 将字符串作为表达式来执行

  ```python
  result = eval('1 + 1')
  ```

- `exec()`: 执行动态代码

- `pickle.loads()`: 反序列化模块，如果反序列化恶意数据，可能导致代码执行

**Java**

在 Java 中，直接执行系统命令的函数相对较少，但依然存在

**命令执行函数**

- `Runtime.getRuntime().exec()`: 在单独的进程中执行指定的字符串命令

  ```java
  Runtime.getRuntime().exec("ls -la");
  ```

- `java.lang.ProcessBuilder`: 创建一个操作系统进程

  ```java
  new ProcessBuilder("ls", "-la").start();
  ```

**代码执行**

- `ScriptEngine`：Java 脚本引擎，可以执行 JavaScript 等脚本语言
- 反序列化：Java 的反序列化漏洞通常是由于 `readObject()` 方法处理不当，结合 `Commons-Collections` 等库中的链式调用，最终实现命令执行