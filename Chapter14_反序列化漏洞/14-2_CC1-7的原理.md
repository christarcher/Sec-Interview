### 讲一下 CC1-7 的原理

**CC1: `InvokerTransformer`**

- **原理**：这是最经典、最著名的利用链。它利用了 `InvokerTransformer` 这个类，它的 `transform` 方法可以通过反射调用任何对象的任何方法
- **攻击链**：
  1. **`LazyMap`**：它是一个惰性加载的 Map，当访问一个不存在的键时，会调用一个 `Transformer` 来生成值
  2. **`InvokerTransformer`**：攻击者将 `InvokerTransformer` 封装到 `LazyMap` 中，并指定其调用 `Runtime.getRuntime().exec()` 方法
  3. **`AnnotationInvocationHandler`**：当 `LazyMap` 被反序列化时，`AnnotationInvocationHandler` 会调用它的 `invoke` 方法，从而触发 `LazyMap` 的 `get` 方法
  4. **`Runtime.exec()`**：最终，`LazyMap` 的 `get` 方法会调用 `InvokerTransformer`，通过反射执行 `Runtime.exec()`，从而执行任意命令
- **绕过**：由于 `InvokerTransformer` 过于危险，它很快被许多安全框架和应用服务器加入了反序列化黑名单

**CC2-CC7：黑名单绕过与新 Gadget Chain 的发现**

在 CC1 被加入黑名单后，研究人员开始寻找新的、没有被列入黑名单的 Gadget Chain。这些新的利用链都遵循同样的原理，只是**利用了不同的类来构建多米诺骨牌**

- **CC2 (`j_object`)**：利用 `Spring` 框架中的 `Javassist` 类库。它通过 `ClassPathXmlApplicationContext` 加载一个远程 XML 文件，从而执行远程代码
- **CC3 (`j_object`)**：利用 `AbstractMap` 的 `hashCode` 方法，通过 `equals` 方法来触发 `InvokerTransformer`
- **CC4 (`j_object`)**：利用 `Spring` 的 `BadAttributeValueExpException` 类。当这个类被反序列化时，它的 `toString` 方法会被调用，从而触发 `InvokerTransformer`
- **CC5 (`j_object`)**：这个利用链与 CC1 类似，但它通过 `TiedMapEntry` 来触发 `LazyMap`，从而绕过了一些针对 `AnnotationInvocationHandler` 的防御
- **CC6 (`j_object`)**：这个利用链也使用了 `TiedMapEntry`，但它通过 `TiedMapEntry` 的 `toString` 方法来触发 `LazyMap`
- **CC7 (`j_object`)**：这个利用链使用 `HashedMap` 的 `readObject` 方法来触发 `AbstractMap` 的 `put` 方法，最终触发 `InvokerTransformer`