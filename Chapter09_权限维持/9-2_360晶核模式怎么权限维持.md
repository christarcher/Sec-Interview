### 360 开启了晶核模式，怎么去尝试权限维持

**1. 放弃传统方法，转向无文件和内存驻留**

在晶核模式下，任何涉及到文件落地、注册表写入、服务创建的传统权限维持方法都极有可能被拦截。因此，我们的核心思想是：**不落地、不留痕、内存驻留**

- **无文件攻击**：避免将任何可执行文件（`.exe`、`.dll`）写入磁盘。所有的恶意代码都应该通过 PowerShell、C# 或其他脚本语言在内存中运行
- **内存驻留**：将恶意代码注入到合法的、白名单内的进程中，如 `svchost.exe`、`explorer.exe` 等。这样，恶意代码就可以利用合法进程的信任度来绕过安全软件的监控
- **使用 PowerShell 或 C#**：利用 PowerShell 的反射式加载（Reflective Loading）技术，可以直接在内存中执行 .NET 程序集。360 晶核模式对 PowerShell 脚本的监控非常严格，因此需要使用混淆、加密等技术来绕过其行为分析

**2. 利用系统自带的合法进程和功能**

晶核模式的核心是识别恶意行为，而不是简单地拦截所有操作。因此，我们可以利用那些系统自带的、360 无法或不敢拦截的合法进程来执行我们的恶意代码

- **利用 `COM` 或 `WMI`**：Windows Management Instrumentation (WMI) 和 Component Object Model (COM) 是系统核心组件，它们允许本地和远程执行代码。许多安全软件无法直接拦截这些操作，因为这可能会导致系统功能异常
  - 你可以通过 `WMI` 在目标机器上**远程执行代码**，而无需将可执行文件写入磁盘。这种方法非常隐蔽，因为 `WMI` 流量是合法的
  - 通过 `COM` 组件，你可以利用那些具有特权的 COM 对象，执行一些平时受限的操作
- **利用计划任务（Scheduled Tasks）**：虽然创建新的计划任务可能会被晶核模式拦截，但你可以尝试修改已有的、合法的计划任务
  - **命令**：`schtasks`
  - **思路**：找到一个不显眼的、定期执行的系统任务，然后修改它的执行命令，让它执行你的无文件后门例如，你可以让它定时执行一个 PowerShell 脚本，该脚本从网络上下载并执行恶意代码
- **利用 `runas` 或其他 Windows API**：如果可以拿到高权限，可以尝试利用 `runas` 或类似的 API 来启动一个拥有更高权限的新进程，然后将恶意代码注入到新进程中

**3. 持久化技巧**

在权限维持方面，可以考虑以下几种高级技巧：

- **DLL 劫持**：找到一个启动时会加载 DLL 的合法程序，并将一个恶意的 DLL 文件放置在它会寻找的路径中。当程序启动时，它会加载你的恶意 DLL，从而执行你的代码
  - **晶核模式的挑战**：晶核模式通常会阻止未签名的 DLL 加载到敏感进程中，因此你需要找到一个没有签名检查的合法程序，或者你的 DLL 需要经过特殊处理
- **COM 劫持**：攻击者可以修改 Windows 注册表中的 COM 组件路径，将合法的 COM 组件替换为恶意的。当应用程序调用这个组件时，就会执行恶意代码
  - **晶核模式的挑战**：晶核模式会对注册表中的关键键值进行监控，因此这种方法需要非常小心，或者找到一个未被监控的注册表键
- **利用驱动程序**：这是最高级的权限维持方法，但难度也最大。你可以尝试加载一个恶意的内核驱动程序。内核驱动拥有最高的权限，可以绕过几乎所有的用户态安全防护
  - **晶核模式的挑战**：360 晶核模式的核心就是内核级防护，它会严格检查所有加载的驱动程序。如果你没有一个经过微软签名的驱动程序，很难成功