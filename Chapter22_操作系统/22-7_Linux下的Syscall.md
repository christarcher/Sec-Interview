### 说说 Linux 下的 Syscall

**什么是系统调用（Syscall）？**

在 Linux（及其他类 Unix 操作系统）中，**系统调用**是用户空间程序（User-space program）与内核（Kernel）之间进行交互的唯一接口

你可以将内核想象成一个操作系统的“核心”，它负责管理和控制计算机的所有硬件资源，例如 CPU、内存、硬盘和网络。而我们日常使用的所有应用程序，比如浏览器、文本编辑器或命令行工具，都运行在**用户空间**

为了确保系统的稳定和安全，用户空间的程序不能直接访问硬件。当一个程序需要做一些“特权”操作时，比如：

- 读写文件
- 创建或销毁进程
- 分配内存
- 发送网络数据包
- 获取当前时间

它就必须通过一个**系统调用**来向内核发出请求。内核会检查这个请求是否合法，如果合法，就会代表用户程序执行这个操作

**系统调用的工作流程**

一个典型的系统调用流程如下：

1. **准备参数**：用户空间的程序将要传递给内核的参数（例如，打开文件时的文件名和权限）放入指定的通用寄存器中
2. **设置系统调用号**：程序将一个唯一的**系统调用号**（Syscall Number）放入另一个特定寄存器（在 x86 架构中通常是 `EAX` 或 `RAX`）中。这个号码告诉内核，程序想要执行哪一个系统调用（比如 `open` 对应 `2`，`read` 对应 `3`）
3. **触发软中断**：程序执行一条特殊的**中断指令**（例如 `int 0x80` 在 32 位系统上，或者 `syscall` 在 64 位系统上）。这条指令会暂停用户程序的执行，并强制 CPU 将控制权从用户空间转移到内核空间
4. **内核处理**：内核接收到中断后，会根据寄存器中的系统调用号，在系统调用表中查找并执行对应的内核函数
5. **返回结果**：内核函数执行完毕后，会将结果（成功或失败的代码）放入一个寄存器中，并执行一条返回指令，将控制权和结果返回给用户空间的程序