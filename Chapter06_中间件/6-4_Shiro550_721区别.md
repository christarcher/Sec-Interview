### Shiro 550 721 区别

**Shiro-550（CVE-2016-4437）**

**Shiro-550** 是利用了 Shiro **硬编码的默认密钥**

- **漏洞原理**：
  1. Apache Shiro 在 `RememberMe` 功能中，会将用户的身份信息进行序列化，然后使用一个**硬编码的默认密钥**进行 AES 加密，最后将加密后的数据作为 Cookie 发送给客户端
  2. 在 **Shiro 1.2.4 及以前的版本**中，这个密钥是固定的、公开的
  3. 攻击者可以利用这个已知的密钥，构造一个恶意的序列化 Payload（即 Gadget Chain，如 `CommonsCollections`）
  4. 攻击者用这个密钥对 Payload 进行加密，然后将加密后的数据作为 `RememberMe` Cookie 发送给服务器
  5. 服务器收到这个 Cookie 后，会使用**相同的默认密钥**对数据进行解密，然后对解密后的数据进行**反序列化**
  6. 在反序列化过程中，恶意的 Gadget Chain 被触发，导致远程代码执行（RCE）
- **攻击流程**：
  1. **获取密钥**：攻击者知道 Shiro 默认的硬编码密钥
  2. **构造 Payload**：利用 `ysoserial` 等工具生成一个反序列化 Payload
  3. **加密 Payload**：用默认密钥对 Payload 进行 AES 加密
  4. **发送 Cookie**：将加密后的数据作为 `RememberMe` Cookie 发送给服务器
  5. **触发反序列化**：服务器解密并反序列化，导致 RCE
- **影响范围**：Shiro <= 1.2.4 版本

**Shiro-721（CVE-2019-12422）**

**Shiro-721** 绕过了默认密钥的问题，它利用的是 **AES-CBC 模式的漏洞**

- **漏洞原理**：
  1. 在 Shiro 1.2.5 到 1.4.1 版本中，虽然移除了硬编码密钥，但攻击者发现，当应用程序使用**一个可猜测或已知的密钥**时，仍然可以利用 AES-CBC 模式的**填充 oracle 攻击**
  2. AES-CBC 模式在解密时，如果数据填充（Padding）不正确，会返回一个特定的错误。攻击者可以利用这个错误来猜测加密数据中的每个字节
  3. 通过这种方式，攻击者可以**逐字节地解密 `RememberMe` Cookie 中的数据**，从而获取加密密钥
  4. 一旦密钥被破解，攻击者就可以像 Shiro-550 一样，构造恶意的 Payload 并进行加密，从而触发 RCE
- **攻击流程**：
  1. **获取密钥**：攻击者利用 AES-CBC 的填充 oracle 漏洞，通过发送大量畸形请求，并根据服务器的响应，逐字节地破解加密密钥
  2. **构造 Payload**：利用 `ysoserial` 生成 Payload
  3. **加密 Payload**：用刚刚破解的密钥对 Payload 进行加密
  4. **发送 Cookie**：将加密后的数据作为 `RememberMe` Cookie 发送给服务器
  5. **触发反序列化**：服务器解密并反序列化，导致 RCE
- **影响范围**：Shiro 1.2.5 - 1.4.1 版本

| 特性     | Shiro-550                  | Shiro-721                                    |
| -------- | -------------------------- | -------------------------------------------- |
| 漏洞类型 | 硬编码密钥导致的反序列化   | AES-CBC 模式的填充 oracle 漏洞               |
| 攻击目标 | 已知密钥                   | 未知密钥                                     |
| 攻击方式 | 直接利用已知的密钥进行加密 | 通过填充 oracle 攻击来破解密钥，然后利用密钥 |
| 利用难度 | 简单，直接利用             | 复杂，需要多次请求进行破解                   |
| 影响版本 | Shiro <= 1.2.4             | Shiro 1.2.5 - 1.4.1                          |